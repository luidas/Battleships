'use strict';

/* eslint-disable no-bitwise */

const os = require('os');
const crypto = require('crypto');
const basex = require('base-x');
const uuidV1 = require('uuid/v1');
const requiredFlake = require('flake');
const AdxError = require('./errors').AdxError;

const BASE58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const bs58 = basex(BASE58);

/**
 * Get a valid interface name.
 *
 * @returns {strint} - the interface name will be used
 * @throws {AdxError} - throws on cannot detect a valid interface
 */
function getInterface() {
    const interfaces = os.networkInterfaces();
    let di; /* keep the docker interface name */
    // eslint-disable-next-line no-restricted-syntax
    for (const n in interfaces) {
        if (!interfaces[n][0].internal) {
            /* avoid return docker network interface directly */
            if (interfaces[n][0].mac.indexOf('02:42:ac:11') === 0) {
                di = n;
            } else {
                return n;
            }
        }
    }
    if (di) return di;
    throw new AdxError('cannot get a valid network interface');
}

/**
 * Static(module scope) interface name
 */
const siname = getInterface();

/**
 * Generate uuid node from mac of the given interface.
 *
 * @param {string} iname - a interface name
 * @returns {Buffer} - Buffer of the mac address as node
 */
function getNode(iname) {
    const mac = os.networkInterfaces()[iname][0].mac;
    let buf;
    /* randomize docker mac address */
    if (mac.indexOf('02:42:ac:11') === 0) {
        buf = crypto.randomBytes(6);
    } else {
        buf = Buffer.from(mac.replace(/:/g, ''), 'hex');
    }
    return buf;
}

/**
 * Static(module scope) node
 */
const snode = getNode(siname);

/**
 * Flake id generator the origin version.
 */
const sflake = requiredFlake(siname);

/**
 * Flake id generator.
 *
 * @returns {string} - the flake id in base58 format
 */
function flake() {
    return bs58.encode(
        Buffer.from(
            sflake().replace(/-/g, ''), 'hex'));
}

/**
 * Uuid1 generator with clockseq to be pid.
 *
 * @param {Buffer} [givenNode] - 48 bits buffer usually from mac address
 * @returns {string} - the uuid1 in base58 format
 */
function uuid1(givenNode) {
    const node = givenNode || snode;
    const buf = Buffer.alloc(16);
    uuidV1({
        node,
        clockseq: process.pid,
    }, buf);
    return bs58.encode(buf);
}

module.exports = Object.assign(uuid1, {
    flake,
    uuid1,
});
