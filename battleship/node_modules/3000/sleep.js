'use strict';

/**
 * Sleep constructor implemented with setTimeout.
 */
function AsyncSleep() {
    let _locked = false;
    let _actions = [];
    let _timeout;

    this.tryLock = () => {
        if (!_locked) {
            _locked = true;
            return true;
        }
        return false;
    };

    this.tryFinish = () => {
        if (_actions.length === 0) {
            _locked = false;
            return true;
        }
        return false;
    };

    this.run = () => {
        if (!this.tryFinish()) {
            const action = _actions.shift();
            const d = action[0];
            const f = action[1];
            _timeout = setTimeout(() => {
                f();
                this.run();
            }, d);
        }
        return this;
    };

    this.sleep = (d, f) => {
        if (typeof d === 'number' && typeof f === 'function') {
            _actions.push([d, f]);
        }
        if (this.tryLock()) {
            this.run();
        }
        return this;
    };

    this.clear = () => {
        _actions = [];
        if (typeof _timeout !== 'undefined') {
            clearTimeout(_timeout);
        }
        return this.tryFinish();
    };
}

/**
 * A sleep function implemented with busy for loop.
 */
function busyLoopSleep(d) {
    for (let t = Date.now(); Date.now() - t <= d;);
}

module.exports.Asleep = AsyncSleep;
module.exports.bsleep = busyLoopSleep;

/**
 * A sleep function implemented with C++ addon.
 */
try {
    // eslint-disable-next-line global-require
    module.exports.csleep = require('./build/Release/addon.node').sleep;
} catch (err) {
    process.stderr.write('failed loading native sleep, using busy loop version instead.\n');
    module.exports.csleep = busyLoopSleep;
}
