'use strict';

const os = require('os');
const cluster = require('cluster');

let logger = console;

/**
 * Ensure is running on master, used on master only.
 */
function ensureMaster() {
    if (!cluster.isMaster) {
        throw new Error('NOT ON MASTER!');
    }
}

/**
 * Check if the master need to exit, used on master only.
 */
function checkExit() {
    ensureMaster();

    if (Object.keys(cluster.workers).length === 0) {
        logger.warn('No childred is alive, master exit now.');
        process.exit(0);
    }
}

/**
 * Shutdown the cluster, used on master only.
 *
 * @param {string} signal - the signal to workers
 */
function killAll(signal = 'SIGTERM') {
    ensureMaster();

    const workers = cluster.workers;
    // eslint-disable-next-line no-restricted-syntax
    for (const i in workers) {
        if (Object.prototype.hasOwnProperty.call(workers, i)) {
            workers[i].kill(signal);
        }
    }
}

/**
 * Ensure system be shut down, used on master only.
 */
function ensureShutdown(signal) {
    ensureMaster();

    if (signal) {
        killAll(signal);
    }

    /* check interval */
    const interval = 1000;
    /* max waiting time */
    const timeout = 1000 * 60;

    logger.warn('I AM THE MASTER WHO WILL STAND UP FOR THE WORKERS!');
    setInterval(() => {
        checkExit();
    }, interval);
    setTimeout(() => {
        logger.error('Timeouted when waiting for childred, master exit now!');
        killAll('SIGKILL');
        process.exit(1);
    }, timeout);
}

/**
 * Monitor the cluster, used on master only.
 *
 * @param {number} numProcs - number of processes
 */
function setMonitor(numProcs) {
    ensureMaster();

    /* monitoring interval */
    const interval = 1000;
    /* max of recently restart times */
    const maxRes = 10;
    /* recently restart times */
    let recRes = 0;
    let alive = true;

    /**
     * Increase recently restart times number
     */
    function inc() {
        recRes += 1;
    }

    /**
     * Decrease recently restart times number
     */
    function dec() {
        recRes -= 1;
    }

    /* set up monitor */
    setInterval(() => {
        let diff = numProcs - Object.keys(cluster.workers).length;
        while (diff > 0) {
            diff -= 1;
            const meta = {
                alive,
                recRes,
                maxRes,
            };
            if (alive && recRes < maxRes) {
                cluster.fork();
                inc();
                setTimeout(dec, interval * 10);
                logger.warn('some nodes died, tried to restart', meta);
            } else {
                alive = false;
                killAll();
                ensureShutdown('SIGTERM');
                logger.error('TOO MANY RESTARTS, SHUTTING DOWN', meta);
                break;
            }
        }
    }, interval);
}

/**
 * Run a function in with cluster.
 *
 * Examples:
 *
 *     clusterRun((msg1, msg2) => {
 *         console.log(msg1, msg2);
 *         process.exit();
 *     }, 10, 'Hello,', 'world!');
 *
 *     function f(){
 *         // do something and exit
 *     }
 *
 *     clusterRun(f);
 *
 * @param {function} f - the function to run
 * @param {number} n - number of nodes, default max(2, number-of-cpus)
 */
function clusterRun(f, n, ...argv) {
    const numCPUs = os.cpus()
        .length;
    const numProcs = n || Math.max(numCPUs, 2);

    if (cluster.isMaster) {
        /* fork workers */
        for (let i = 0; i < numProcs; i += 1) {
            cluster.fork();
        }
        cluster.on('exit', (worker, code, signal) => {
            logger.warn('A worker died, a mournful story!', {
                code,
                signal,
                pid: worker.process.pid,
            });
            /* check if all processes terminaled then exit directly */
            checkExit();
        });
        process.on('SIGINT', ensureShutdown);
        setMonitor(numProcs);
    } else {
        f(...argv);
    }
}

/** Just pass in a logger */
function useLogger(incommingLogger) {
    if (incommingLogger) logger = incommingLogger;
    /** for chain calls */
    return clusterRun;
}

module.exports = Object.assign(clusterRun, {
    useLogger,
    clusterRun,
    run: clusterRun,
});

/* simple testing code */
if (!module.parent) {
    clusterRun((msg1, msg2) => {
        logger.info(msg1, msg2);
        process.exit();
    }, 10, 'Hello,', 'world!');
}
